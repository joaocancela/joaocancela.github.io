<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Voto por Demografia (MVP)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; max-width: 1150px; }
    h1 { margin: 0 0 10px; font-size: 20px; }
    .small { color: #555; font-size: 13px; margin-top: 6px; }
    table { border-collapse: collapse; width: 100%; margin-top: 14px; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: middle; }
    th { background: #f6f6f6; text-align: left; }
    td.num { width: 98px; white-space: nowrap; text-align: right; }
    input { font-size: 14px; padding: 6px 8px; width: 88px; text-align: right; }
    button { font-size: 14px; padding: 6px 10px; }

    .result { margin-top: 14px; padding: 12px; border: 1px solid #ddd; background: #fafafa; }
    .barwrap { margin-top: 10px; }
    .bar { height: 14px; background: #e6e6e6; border-radius: 8px; overflow: hidden; }
    .seg { height: 100%; display: inline-block; }

    .errorbox { margin-top: 12px; padding: 10px 12px; border: 1px solid #b00020; background: #fff5f6; color: #8b0018; }
    .rowbad { background: #fff5f6; }
    .sumok { color: #1b5e20; font-weight: 600; }
    .sumbad { color: #b00020; font-weight: 700; }

    .totalrow td { background: #f8f8f8; font-weight: 700; }
    .muted { color: #666; font-weight: 600; }

    /* segment colors (5) */
    .c0 { background: #4c78a8; }
    .c1 { background: #f58518; }
    .c2 { background: #54a24b; }
    .c3 { background: #e45756; }
    .c4 { background: #72b7b2; }
  </style>
</head>
<body>
  <h1>Simulador de Voto por Demografia (MVP)</h1>

  <div class="small">
    Preencha percentagens inteiras (0–100) por cada um dos 8 grupos (idade × género × escolaridade).
    Cada linha tem de somar <strong>exatamente</strong> 100%.
  </div>

  <div class="small">
    Nota: está a distribuir 100% <em>apenas</em> por estes 5 candidatos (não há “Outros” / brancos / indecisos).
  </div>

  <div style="margin-top:10px;">
    <button id="resetBtn" type="button">Repor (20 em tudo)</button>
  </div>

  <div id="app"></div>

  <div id="validation" class="errorbox" style="display:none;"></div>

  <div class="result">
    <strong>Resultado:</strong>
    <div id="verdict" style="margin-top:8px;"></div>

    <div class="barwrap">
      <div class="bar" id="overallBar"></div>
    </div>

    <div class="small" style="margin-top:10px;">
      Regra: 1.ª volta se algum candidato tiver <strong>50%+1 ponto percentual</strong> (isto é, ≥ 51.0%).
      Caso contrário, passam os dois primeiros.
    </div>
  </div>

<script>
/**
 * 5 candidatos, ordem aleatória no carregamento (reduz primacy effects).
 */
const CANDIDATES_BASE = [
  { key: "av",  label: "André Ventura" },
  { key: "jcf", label: "João Cotrim de Figueiredo" },
  { key: "hgm", label: "Henrique Gouveia e Melo" },
  { key: "ajs", label: "António José Seguro" },
  { key: "lmm", label: "Luís Marques Mendes" }
];

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
const CANDIDATES = shuffle(CANDIDATES_BASE);

/**
 * 8 células (idade → género → escolaridade).
 * Pesos (%): ESCOLARIEDADE==99 removido e renormalizado.
 */
const CELLS = [
  // 18-54
  { id:"u55_h_nps", age:"18-54", gender:"Homem",  edu:"Básico - Secundário",     w:16.9533 },
  { id:"u55_h_ps",  age:"18-54", gender:"Homem",  edu:"Ensino Pós-Secundário",  w:12.13539 },
  { id:"u55_m_nps", age:"18-54", gender:"Mulher", edu:"Básico - Secundário",     w:14.80357 },
  { id:"u55_m_ps",  age:"18-54", gender:"Mulher", edu:"Ensino Pós-Secundário",  w:16.89007 },

  // 55+
  { id:"55p_h_nps", age:"55+", gender:"Homem",  edu:"Básico - Secundário",     w:15.49064 },
  { id:"55p_h_ps",  age:"55+", gender:"Homem",  edu:"Ensino Pós-Secundário",  w: 4.35424 },
  { id:"55p_m_nps", age:"55+", gender:"Mulher", edu:"Básico - Secundário",     w:14.30619 },
  { id:"55p_m_ps",  age:"55+", gender:"Mulher", edu:"Ensino Pós-Secundário",  w: 5.066599 },
];

const SUM_TOL = 0; // exact 100

let state = {}; // { [cellId]: { [candidateKey]: int } }

function initState20() {
  state = {};
  for (const cell of CELLS) {
    state[cell.id] = {};
    for (const c of CANDIDATES) state[cell.id][c.key] = 20;
  }
}

function el(tag, attrs={}, children=[]) {
  const node = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (k === "class") node.className = v;
    else if (k === "html") node.innerHTML = v;
    else node.setAttribute(k, v);
  }
  for (const c of children) node.appendChild(c);
  return node;
}

function fmtPct(x, d=2) { return `${x.toFixed(d)}%`; }

function clampInt(v) {
  if (Number.isNaN(v)) return 0;
  v = Math.round(v);
  v = Math.max(0, Math.min(100, v));
  return v;
}

function rowSum(cellId) {
  let s = 0;
  for (const c of CANDIDATES) s += (state[cellId][c.key] ?? 0);
  return s;
}

function allRowsValid() {
  for (const cell of CELLS) {
    const s = rowSum(cell.id);
    if (Math.abs(100 - s) > SUM_TOL) return false;
  }
  return true;
}

/**
 * Running weighted totals (no normalization): gives feedback even if rows incomplete.
 */
function computeRunningTotals() {
  const totals = {};
  for (const c of CANDIDATES) totals[c.key] = 0;

  for (const cell of CELLS) {
    const w = cell.w / 100.0;
    for (const cand of CANDIDATES) {
      totals[cand.key] += w * ((state[cell.id][cand.key] ?? 0) / 100.0);
    }
  }
  return totals;
}

/**
 * Valid overall totals (sum to 1) only if every row sums to 100.
 */
function computeOverallIfValid() {
  if (!allRowsValid()) return null;
  return computeRunningTotals(); // with all rows valid, sums to 1
}

function verdictFromOverall(overall) {
  const ranked = CANDIDATES.map(c => ({
    key: c.key,
    label: c.label,
    share: overall[c.key]
  })).sort((a,b) => b.share - a.share);

  const top = ranked[0];
  const topPct = top.share * 100;

  if (topPct >= 51.0) {
    return `Candidato ganha à primeira volta: <strong>${top.label}</strong> (${topPct.toFixed(1)}%).`;
  }
  const second = ranked[1];
  return `Não há vencedor à primeira volta. Passam à segunda volta: <strong>${top.label}</strong> (${topPct.toFixed(1)}%) e <strong>${second.label}</strong> (${(second.share*100).toFixed(1)}%).`;
}

function renderTable() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const table = el("table");
  const thead = el("thead");
  const trh = el("tr");

  trh.appendChild(el("th", { html: "Idade" }));
  trh.appendChild(el("th", { html: "Género" }));
  trh.appendChild(el("th", { html: "Escolaridade" }));
  trh.appendChild(el("th", { html: "Peso no eleitorado (2024)" }));

  for (const c of CANDIDATES) trh.appendChild(el("th", { html: `${c.label} (%)` }));
  trh.appendChild(el("th", { html: "Soma" }));

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = el("tbody");

  CELLS.forEach((cell) => {
    const tr = el("tr", { id: `row_${cell.id}` });

    tr.appendChild(el("td", { html: cell.age }));
    tr.appendChild(el("td", { html: cell.gender }));
    tr.appendChild(el("td", { html: cell.edu }));
    tr.appendChild(el("td", { class: "num", html: fmtPct(cell.w, 2) }));

    CANDIDATES.forEach((cand) => {
      const input = el("input", {
        type: "number",
        min: "0",
        max: "100",
        step: "1",
        inputmode: "numeric",
        value: String(state[cell.id][cand.key] ?? 0)
      });

      input.addEventListener("input", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        update();
      });

      input.addEventListener("change", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        input.value = String(v);
        update();
      });

      input.addEventListener("blur", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        input.value = String(v);
        update();
      });

      const td = el("td");
      td.appendChild(input);
      tr.appendChild(td);
    });

    tr.appendChild(el("td", { class:"num", id:`sum_${cell.id}` }));
    tbody.appendChild(tr);
  });

  // TOTAL row (running weighted totals, real-time)
  const totalTr = el("tr", { class: "totalrow", id: "totalRow" });
  totalTr.appendChild(el("td", { html: "Total ponderado", colspan: "4" }));

  CANDIDATES.forEach((cand) => {
    totalTr.appendChild(el("td", { class: "num", id: `tot_${cand.key}`, html: "<span class='muted'>0.0%</span>" }));
  });

  totalTr.appendChild(el("td", { class: "num", id: "tot_sum", html: "<span class='muted'>0.0%</span>" }));
  tbody.appendChild(totalTr);

  table.appendChild(tbody);
  app.appendChild(table);

  app.appendChild(el("div", {
    class:"small",
    html: "Nota: “Ensino Pós-Secundário” = Bacharelato/Ensino Médio ou Licenciatura+ (categorias 6 ou 7). “Não quer responder” foi excluído dos pesos."
  }));
}

function updateRowSumsAndHighlight() {
  let badRows = [];
  for (const cell of CELLS) {
    const s = rowSum(cell.id);
    const sumEl = document.getElementById(`sum_${cell.id}`);
    const rowEl = document.getElementById(`row_${cell.id}`);

    const ok = (s === 100);
    if (sumEl) {
      sumEl.textContent = s + "%";
      sumEl.className = "num " + (ok ? "sumok" : "sumbad");
    }
    if (rowEl) rowEl.classList.toggle("rowbad", !ok);
    if (!ok) badRows.push({ cell, sum: s });
  }

  const validation = document.getElementById("validation");
  if (badRows.length > 0) {
    validation.style.display = "block";
    const items = badRows.map(r =>
      `<li><strong>${r.cell.age}</strong> · ${r.cell.gender} · ${r.cell.edu}: soma = ${r.sum}%</li>`
    ).join("");
    validation.innerHTML = `
      <div><strong>Corrigir antes de obter o resultado:</strong> cada linha tem de somar 100% (valores inteiros).</div>
      <ul style="margin:8px 0 0 20px;">${items}</ul>
    `;
  } else {
    validation.style.display = "none";
    validation.innerHTML = "";
  }
}

function renderTotalsRow(totals) {
  let sum = 0;
  CANDIDATES.forEach((cand) => {
    const v = totals[cand.key] * 100;
    sum += v;
    const cell = document.getElementById(`tot_${cand.key}`);
    if (cell) cell.innerHTML = `${v.toFixed(1)}%`;
  });
  const sEl = document.getElementById("tot_sum");
  if (sEl) sEl.innerHTML = `${sum.toFixed(1)}%`;
}

function renderBar(overallOrRunning) {
  const bar = document.getElementById("overallBar");
  bar.innerHTML = "";
  if (!overallOrRunning) return;

  CANDIDATES.forEach((c, idx) => {
    const width = (overallOrRunning[c.key] * 100);
    const seg = el("span", { class: `seg c${idx}`, style: `width:${Math.max(0, width).toFixed(4)}%` });
    bar.appendChild(seg);
  });
}

function update() {
  updateRowSumsAndHighlight();

  // Always update running totals row
  const running = computeRunningTotals();
  renderTotalsRow(running);

  // Verdict only if valid
  const verdictEl = document.getElementById("verdict");
  const overall = computeOverallIfValid();

  if (!overall) {
    verdictEl.innerHTML = "—";
    renderBar(running);
    return;
  }

  verdictEl.innerHTML = verdictFromOverall(overall);
  renderBar(overall);
}

document.getElementById("resetBtn").addEventListener("click", () => {
  initState20();
  renderTable();
  update();
});

// boot
initState20();
renderTable();
update();
</script>
</body>
</html>
