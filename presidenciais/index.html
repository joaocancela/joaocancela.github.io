<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Voto por Demografia (MVP)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; max-width: 1100px; }
    h1 { margin: 0 0 10px; font-size: 20px; }
    .small { color: #555; font-size: 13px; margin-top: 6px; }
    table { border-collapse: collapse; width: 100%; margin-top: 14px; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: middle; }
    th { background: #f6f6f6; text-align: left; }
    td.num { width: 92px; white-space: nowrap; }
    input { font-size: 14px; padding: 6px 8px; width: 88px; }
    button { font-size: 14px; padding: 6px 10px; }

    .result { margin-top: 14px; padding: 12px; border: 1px solid #ddd; background: #fafafa; }
    .barwrap { margin-top: 10px; }
    .bar { height: 14px; background: #e6e6e6; border-radius: 8px; overflow: hidden; }
    .seg { height: 100%; display: inline-block; }

    .errorbox { margin-top: 12px; padding: 10px 12px; border: 1px solid #b00020; background: #fff5f6; color: #8b0018; }
    .rowbad { background: #fff5f6; }
    .sumok { color: #1b5e20; font-weight: 600; }
    .sumbad { color: #b00020; font-weight: 700; }

    /* segment colors */
    .c0 { background: #4c78a8; }
    .c1 { background: #f58518; }
    .c2 { background: #54a24b; }
    .c3 { background: #e45756; }
    .c4 { background: #72b7b2; }
    .c5 { background: #bdbdbd; }
  </style>
</head>
<body>
  <h1>Simulador de Voto por Demografia (MVP)</h1>

  <div class="small">
    Preencha percentagens inteiras (0–100) por cada um dos 8 grupos (idade × género × escolaridade).
    Cada linha tem de somar <strong>exatamente</strong> 100%.
  </div>

  <div style="margin-top:10px;">
    <button id="resetBtn" type="button">Repor (valores iguais)</button>
  </div>

  <div id="app"></div>

  <div id="validation" class="errorbox" style="display:none;"></div>

  <div class="result">
    <strong>Resultado:</strong>
    <div id="verdict" style="margin-top:8px;"></div>

    <div class="barwrap">
      <div class="bar" id="overallBar"></div>
    </div>

    <div class="small" style="margin-top:10px;">
      Regra: 1.ª volta se algum candidato tiver <strong>50%+1 ponto percentual</strong> (isto é, ≥ 51.0%).
      Caso contrário, passam os dois primeiros.
    </div>
  </div>

<script>
/**
 * CONFIG: 6 opções (5 nomes aleatorizados + "Outros" sempre no fim).
 * "Outros" corresponde ao agregado (Catarina Martins + Jorge Pinto + António Filipe).
 */
const FIXED_LAST = { key: "outros", label: "Outros" };
const CANDIDATES_BASE = [
  { key: "av",  label: "André Ventura" },
  { key: "jcf", label: "João Cotrim de Figueiredo" },
  { key: "hgm", label: "Henrique Gouveia e Melo" },
  { key: "ajs", label: "António José Seguro" },
  { key: "lmm", label: "Luís Marques Mendes" }
];

// Fisher–Yates shuffle
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

const CANDIDATES = [...shuffle(CANDIDATES_BASE), FIXED_LAST];

/**
 * CONFIG: 8 células na ordem pedida:
 * Idade (<55, 55+) → Género (Homem, Mulher) → Escolaridade (Não pós-secundário, Ensino Pós-Secundário)
 * Pesos (%): (ESCOLARIEDADE==99 removido e renormalizado).
 */
const CELLS = [
  // <55
  { id:"u55_h_nps", age:"<55", gender:"Homem",  edu:"Não pós-secundário",     w:16.9533 },
  { id:"u55_h_ps",  age:"<55", gender:"Homem",  edu:"Ensino Pós-Secundário",  w:12.13539 },
  { id:"u55_m_nps", age:"<55", gender:"Mulher", edu:"Não pós-secundário",     w:14.80357 },
  { id:"u55_m_ps",  age:"<55", gender:"Mulher", edu:"Ensino Pós-Secundário",  w:16.89007 },

  // 55+
  { id:"55p_h_nps", age:"55+", gender:"Homem",  edu:"Não pós-secundário",     w:15.49064 },
  { id:"55p_h_ps",  age:"55+", gender:"Homem",  edu:"Ensino Pós-Secundário",  w: 4.35424 },
  { id:"55p_m_nps", age:"55+", gender:"Mulher", edu:"Não pós-secundário",     w:14.30619 },
  { id:"55p_m_ps",  age:"55+", gender:"Mulher", edu:"Ensino Pós-Secundário",  w: 5.066599 },
];

// Hard constraint: exact 100 (integers), so no tolerance.
const SUM_TOL = 0;

// State: per cell, candidate shares in integer %
let state = {}; // { [cellId]: { [candidateKey]: number } }

function initStateEqual() {
  state = {};
  const base = Math.floor(100 / CANDIDATES.length); // 16
  const rem = 100 - base * CANDIDATES.length;       // 4
  for (const cell of CELLS) {
    state[cell.id] = {};
    CANDIDATES.forEach((c, idx) => {
      state[cell.id][c.key] = base + (idx < rem ? 1 : 0);
    });
  }
}

function el(tag, attrs={}, children=[]) {
  const node = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (k === "class") node.className = v;
    else if (k === "html") node.innerHTML = v;
    else node.setAttribute(k, v);
  }
  for (const c of children) node.appendChild(c);
  return node;
}

function fmtPct(x, d=2) { return `${x.toFixed(d)}%`; }

function rowSum(cellId) {
  let s = 0;
  for (const c of CANDIDATES) s += (state[cellId][c.key] ?? 0);
  return s;
}

function allRowsValid() {
  for (const cell of CELLS) {
    const s = rowSum(cell.id);
    if (Math.abs(100 - s) > SUM_TOL) return false;
  }
  return true;
}

function clampInt(v) {
  if (Number.isNaN(v)) return 0;
  v = Math.round(v);
  v = Math.max(0, Math.min(100, v));
  return v;
}

function renderTable() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const table = el("table");
  const thead = el("thead");
  const trh = el("tr");

  trh.appendChild(el("th", { html: "Idade" }));
  trh.appendChild(el("th", { html: "Género" }));
  trh.appendChild(el("th", { html: "Escolaridade" }));
  trh.appendChild(el("th", { html: "Peso" }));

  for (const c of CANDIDATES) trh.appendChild(el("th", { html: `${c.label} (%)` }));
  trh.appendChild(el("th", { html: "Soma" }));

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = el("tbody");

  CELLS.forEach((cell) => {
    const tr = el("tr", { id: `row_${cell.id}` });

    tr.appendChild(el("td", { html: cell.age }));
    tr.appendChild(el("td", { html: cell.gender }));
    tr.appendChild(el("td", { html: cell.edu }));
    tr.appendChild(el("td", { class: "num", html: fmtPct(cell.w, 2) }));

    CANDIDATES.forEach((cand) => {
      const input = el("input", {
        type: "number",
        min: "0",
        max: "100",
        step: "1",
        inputmode: "numeric",
        value: String(state[cell.id][cand.key] ?? 0)
      });

      // On input, clamp to int but don't force-correct the visible value mid-typing too aggressively;
      // we'll normalize the display on blur/change.
      input.addEventListener("input", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        update(false);
      });

      input.addEventListener("change", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        input.value = String(v);
        update(true);
      });

      input.addEventListener("blur", () => {
        const v = clampInt(parseFloat(input.value));
        state[cell.id][cand.key] = v;
        input.value = String(v);
        update(true);
      });

      const td = el("td");
      td.appendChild(input);
      tr.appendChild(td);
    });

    tr.appendChild(el("td", { class:"num", id:`sum_${cell.id}` }));
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  app.appendChild(table);

  app.appendChild(el("div", {
    class:"small",
    html: "Nota: “Ensino Pós-Secundário” = Bacharelato/Ensino Médio ou Licenciatura+ (categorias 6 ou 7). “Não quer responder” foi excluído dos pesos."
  }));
}

/**
 * Compute overall shares as proportions (sum to 1), only if valid.
 */
function computeOverall() {
  if (!allRowsValid()) return null;

  const overall = {};
  for (const c of CANDIDATES) overall[c.key] = 0;

  for (const cell of CELLS) {
    const w = cell.w / 100.0;
    for (const cand of CANDIDATES) {
      overall[cand.key] += w * (state[cell.id][cand.key] / 100.0);
    }
  }
  return overall;
}

/**
 * Determine verdict:
 * - Winner in 1st round if >= 51.0% (50%+1 pp)
 * - Else top 2 go to 2nd round
 */
function verdictFromOverall(overall) {
  // Build ranked list
  const ranked = CANDIDATES.map(c => ({
    key: c.key,
    label: c.label,
    share: overall[c.key] // proportion
  }))
  .sort((a,b) => b.share - a.share);

  const top = ranked[0];
  const topPct = top.share * 100;

  if (topPct >= 51.0) {
    return `Candidato ganha à primeira volta: <strong>${top.label}</strong> (${topPct.toFixed(1)}%).`;
  }

  const second = ranked[1];

  // Handle potential tie for 2nd in a simple, deterministic way: list the top 2 by sort order.
  return `Não há vencedor à primeira volta. Passam à segunda volta: <strong>${top.label}</strong> (${topPct.toFixed(1)}%) e <strong>${second.label}</strong> (${(second.share*100).toFixed(1)}%).`;
}

function updateRowSumsAndHighlight() {
  let badRows = [];
  for (const cell of CELLS) {
    const s = rowSum(cell.id);
    const sumEl = document.getElementById(`sum_${cell.id}`);
    const rowEl = document.getElementById(`row_${cell.id}`);

    const ok = (s === 100);
    if (sumEl) {
      sumEl.textContent = s + "%";
      sumEl.className = "num " + (ok ? "sumok" : "sumbad");
    }
    if (rowEl) rowEl.classList.toggle("rowbad", !ok);
    if (!ok) badRows.push({ cell, sum: s });
  }

  const validation = document.getElementById("validation");
  if (badRows.length > 0) {
    validation.style.display = "block";
    const items = badRows.map(r =>
      `<li><strong>${r.cell.age}</strong> · ${r.cell.gender} · ${r.cell.edu}: soma = ${r.sum}%</li>`
    ).join("");
    validation.innerHTML = `
      <div><strong>Corrigir antes de obter o resultado:</strong> cada linha tem de somar 100% (valores inteiros).</div>
      <ul style="margin:8px 0 0 20px;">${items}</ul>
    `;
  } else {
    validation.style.display = "none";
    validation.innerHTML = "";
  }
}

function renderBar(overall) {
  const overallBar = document.getElementById("overallBar");
  overallBar.innerHTML = "";
  if (!overall) return;

  CANDIDATES.forEach((c, idx) => {
    const width = (overall[c.key] * 100);
    const seg = el("span", { class: `seg c${idx}`, style: `width:${width.toFixed(4)}%` });
    overallBar.appendChild(seg);
  });
}

function update(forceRecalcText) {
  // forceRecalcText param kept for cleanliness; not strictly necessary.
  updateRowSumsAndHighlight();

  const verdictEl = document.getElementById("verdict");
  const overall = computeOverall();

  if (!overall) {
    verdictEl.innerHTML = "—";
    renderBar(null);
    return;
  }

  verdictEl.innerHTML = verdictFromOverall(overall);
  renderBar(overall);
}

document.getElementById("resetBtn").addEventListener("click", () => {
  initStateEqual();
  renderTable();
  update(true);
});

// boot
initStateEqual();
renderTable();
update(true);
</script>
</body>
</html>
